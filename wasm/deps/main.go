// Generated by ChatGPT >:| ... its shit, but its just a one-off utility
package main

import (
	"bufio"
	"encoding/json"
	"flag"
	"fmt"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"sort"
	"strings"
)

var dryRun bool
var force bool
var limit int

type Config struct {
	Ignore  []string          `json:"ignore"`
	Rewrite map[string]string `json:"rewrite"`
}

func main() {
	modPath := flag.String("mod", "go.mod", "Path to the go.mod file")
	flag.BoolVar(&dryRun, "dry", false, "Dry run mode (no file or system changes)")
	flag.BoolVar(&force, "force", false, "Force reprocess dependencies even if folder exists")
	flag.IntVar(&limit, "limit", 0, "Limit number of dependencies to process (0 = no limit)")
	configPath := flag.String("config", "config.json", "Path to config.json for ignore/rewrite rules")
	flag.Parse()

	file, err := os.Open(*modPath)
	if err != nil {
		log.Fatalf("Failed to open %s: %v", *modPath, err)
	}
	defer file.Close()

	config := Config{}
	configFile, err := os.ReadFile(*configPath)
	if err != nil && !os.IsNotExist(err) {
		log.Fatalf("Failed to read config file: %v", err)
	} else if err == nil {
		if err := json.Unmarshal(configFile, &config); err != nil {
			log.Fatalf("Failed to parse config file: %v", err)
		}
	}

	depSet := make(map[string]struct{})

	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		if strings.HasPrefix(line, "require") ||
			strings.HasPrefix(line, ")") ||
			strings.HasPrefix(line, "module") ||
			strings.HasPrefix(line, "replace") {
			continue // Skip lines like 'require (' or ')'
		}
		if strings.Contains(line, "/") {
			parts := strings.Fields(line)
			if len(parts) >= 1 {
				depSet[parts[0]] = struct{}{}
			}
		}
	}

	if err := scanner.Err(); err != nil {
		log.Fatalf("Error reading %s: %v", *modPath, err)
	}

	deps := make([]string, 0, len(depSet))
	for dep := range depSet {
		deps = append(deps, dep)
	}
	sort.Strings(deps)

	failedDeps := []string{}
	ignoredDeps := []string{}

	processed := 0
	for _, dep := range deps {
		if contains(config.Ignore, dep) {
			fmt.Printf("Ignoring dependency (via config): %s\n", dep)
			ignoredDeps = append(ignoredDeps, dep)
			continue
		}

		if newDep, ok := config.Rewrite[dep]; ok {
			fmt.Printf("Rewriting dependency %s -> %s\n", dep, newDep)
			dep = newDep
		}
		if limit > 0 && processed >= limit {
			fmt.Printf("Limit of %d dependencies reached. Stopping.\n", limit)
			break
		}

		folderName := strings.ReplaceAll(dep, "/", "-")
		if _, err := os.Stat(folderName); err == nil && !force {
			fmt.Printf("Skipping existing folder: %s\n", folderName)
			ignoredDeps = append(ignoredDeps, folderName)
			continue
		}

		if dryRun {
			fmt.Printf("===========================\n")
			fmt.Printf("[Dry] create folder: %s\n", folderName)
			fmt.Printf("[Dry] write main.go with import: %s\n", dep)
			fmt.Printf("[Dry] run: go mod init %s\n", folderName)
			fmt.Printf("[Dry] run: go get\n")
			fmt.Printf("[Dry] Would run: go mod tidy\n\n")
			processed++
			continue
		}

		if err := os.RemoveAll(folderName); err != nil && force {
			log.Printf("Failed to remove existing folder for %s: %v", dep, err)
			failedDeps = append(failedDeps, dep)
			continue
		}

		if err := os.Mkdir(folderName, 0755); err != nil {
			log.Printf("Failed to create folder for %s: %v", dep, err)
			failedDeps = append(failedDeps, dep)
			continue
		}

		if err := os.WriteFile(filepath.Join(folderName, "main.go"), []byte(fmt.Sprintf(`package main

import (
	_ "%s"
)

func main() {}
`, dep)), 0644); err != nil {
			log.Printf("Failed to write main.go for %s: %v", dep, err)
			failedDeps = append(failedDeps, dep)
			continue
		}

		if err := runCmd(folderName, "go", "mod", "init", folderName); err != nil {
			log.Printf("go mod init failed for %s: %v", dep, err)
			failedDeps = append(failedDeps, dep)
			continue
		}

		if err := runCmd(folderName, "go", "get"); err != nil {
			log.Printf("go get failed for %s: %v", dep, err)
			failedDeps = append(failedDeps, dep)
			continue
		}

		if err := runCmd(folderName, "go", "mod", "tidy"); err != nil {
			log.Printf("go mod tidy failed for %s: %v", dep, err)
			failedDeps = append(failedDeps, dep)
			continue
		}

		fmt.Printf("Processed: %s\n", dep)
		processed++
	}

	if len(failedDeps) == 0 {
		fmt.Println("\nAll dependencies processed successfully.")
	}

	logContent := fmt.Sprintf(`Dependency Processing Summary:

Total dependencies found: %d
Processed successfully: %d
Ignored: %d
Failed: %d

Ignored Dependencies:
 - %s

Failed Dependencies:
 - %s
`,
		len(deps),
		processed,
		len(ignoredDeps),
		len(failedDeps),
		strings.Join(ignoredDeps, "\n - "),
		strings.Join(failedDeps, "\n - "))

	fmt.Println(logContent)
	_ = os.WriteFile("deps.log", []byte(logContent), 0644)
}

func contains(slice []string, item string) bool {
	for _, s := range slice {
		if s == item {
			return true
		}
	}
	return false
}

func getListOrNA(all []string, processed int, ignored []string, failed []string, category string) []string {
	if category == "processed" {
		ignoreMap := make(map[string]bool)
		failMap := make(map[string]bool)
		for _, dep := range ignored {
			ignoreMap[dep] = true
		}
		for _, dep := range failed {
			failMap[dep] = true
		}
		out := []string{}
		for _, dep := range all {
			if !ignoreMap[dep] && !failMap[dep] {
				out = append(out, dep)
			}
		}
		return out
	}
	return []string{"n/a"}
}

func runCmd(dir string, name string, args ...string) error {
	if dryRun {
		fmt.Printf("[Dry Run] Would run command in %s: %s %s\n", dir, name, strings.Join(args, " "))
		return nil
	}
	cmd := exec.Command(name, args...)
	cmd.Dir = dir
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	return cmd.Run()
}
